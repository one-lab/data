package org.onelab.data.conn;


import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 数据库连接管理器
 * @author Chunliang.Han on 15/8/10.
 */
public class ConnectionPool {

  /**
   * 数据库连接管理器
   */
  final ConnectionWrap connWrap;

  /**
   * 线程绑定数据库连接
   */
  final ThreadLocal<Connection> connLocal;

  /**
   * 数据库连接缓存区
   */
  final LinkedBlockingQueue<Connection> connPool;

  /**
   * 连接池管理器
   */
  final ConnectionPoolStuffer stuffer;

  /**
   * 最大连接数，仅表示连接池内的连接数上线，并不代表当前活跃连接数。
   * 当前活跃连接数<=线程数+minPoolSize
   */
  final int maxPoolSize;

  /**
   * 最小连接数，如果小于等于0，则现用现创建
   */
  final int minPoolSize;

  /**
   * 连接失效时间（秒），如果小于等于0，则立即失效
   * 达到该时间，如果线程池中仍有连接，则该连接一定会被重置，不会关注该连接创建于何时
   */
  final int invalidTime;

  private final Lock initPoolLock = new ReentrantLock();

  private final Condition initPoolCondition = initPoolLock.newCondition();

  public ConnectionPool(Config config) {
    maxPoolSize = config.getMaxPoolSize();
    minPoolSize = config.getMinPoolSize();
    invalidTime = config.getInvalidTime();
    connWrap = new ConnectionWrap(config.getDriver(), config.getUrl(), config.getUser(), config.getPassword());
    connLocal = new ThreadLocal<Connection>();
    connPool = new LinkedBlockingQueue<Connection>(maxPoolSize);
    stuffer = new ConnectionPoolStuffer(this);
  }

  /**
   * 当前连接数
   * @return
   */
  public int size(){
    return connPool.size();
  }

  /**
   * 关闭当前线程中连接。
   * 实际上执行的是将连接还回缓冲区的操作
   * 如果当前连接存在且已开启自动提交则执行相关操作，否则直接返回
   * 从线程变量中将连接删除
   * 如果已经关闭，则直接返回
   * 尝试将连接放回缓存区
   * 如果还回缓冲区失败则尝试关闭连接
   */
  public void close() {
    Connection connection = connLocal.get();
    if (connection != null &&
        connWrap.isAutoCommit(connection)) {
      close(connection);
    }
  }

  public void close(Connection connection){
    connLocal.remove();
    //如果连接已关闭直接返回
    if (connWrap.isClosed(connection)) {
      return;
    }
    //失效时间小于或等于0，直接销毁
    if (invalidTime <= 0){
      connWrap.close(connection);
      return;
    }
    //尝试将连接放回池中
    if (!connPool.offer(connection)) {
      //放回池中失败，关闭连接
      connWrap.close(connection);
    }
  }

  /**
   * 关闭会话
   * @param pstm
   */
  public void close(PreparedStatement pstm) {
    if (pstm != null) {
      try {
        pstm.close();
      } catch (SQLException e) {}
    }
    close();
  }

  /**
   * 关闭查询同时关闭会话
   * @param pstm
   * @param resultSet
   */
  public void close(PreparedStatement pstm, ResultSet resultSet) {
    if (resultSet != null) {
      try {
        resultSet.close();
      } catch (SQLException e) {}
    }
    close(pstm);
  }

  /**
   * 获取会话
   * @param sql
   * @param params
   * @return
   */
  public PreparedStatement getPreparedStatement(String sql, Object[] params) {
    try {
      PreparedStatement pstm = getConnection().prepareStatement(sql);
      if (params != null) {
        for (int i = 0; i < params.length; i++) {
          pstm.setObject(i + 1, params[i]);
        }
      }
      return pstm;
    } catch (SQLException e) {
      throw new RuntimeException("PreparedStatement 获取失败", e);
    }
  }

  /**
   * 获取会话
   * @param sql
   * @param params
   * @param autoGeneratedKeys
   * @return
   */
  public PreparedStatement getPreparedStatement(String sql, Object[] params,int autoGeneratedKeys) {
    try {
      PreparedStatement pstm = getConnection().prepareStatement(sql, autoGeneratedKeys);
      if (params != null) {
        for (int i = 0; i < params.length; i++) {
          pstm.setObject(i + 1, params[i]);
        }
      }
      return pstm;
    } catch (SQLException e) {
      throw new RuntimeException("PreparedStatement 获取失败", e);
    }
  }

  /**
   * 获取数据库连接
   * @return
   */
  public Connection getConnection() {
    signalInit();
    Connection conn = connLocal.get();
    if (conn != null) {
      return conn;
    }
    conn = getConnectionFromPool();
    connLocal.set(conn);
    return conn;
  }

  /**
   * 从缓冲区中获取连接
   * 如果没有则创建连接
   * @return
   */
  private Connection getConnectionFromPool() {
    Connection connection = null;
    try {
      connection = connPool.poll(200, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {}
    if (connection == null) {
      connection = connWrap.getConnection();
    }
    return connection;
  }

  /**
   * 通知初始化连接池
   */
  void signalInit(){
    boolean isLock = initPoolLock.tryLock();
    if (isLock){
      try {
        initPoolCondition.signal();
      } finally {
        initPoolLock.unlock();
      }
    }
  }

  /**
   * 等待初始化连接池
   */
  void waitToInitPool(){
    boolean isLock = initPoolLock.tryLock();
    if (isLock){
      try {
        initPoolCondition.await(1, TimeUnit.MINUTES);
      } catch (InterruptedException t){
        //等待到时间，应该开始初始化了
      } finally {
        initPoolLock.unlock();
      }
    }
  }
}
